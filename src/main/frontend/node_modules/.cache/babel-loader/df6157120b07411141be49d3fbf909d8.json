{"ast":null,"code":"/*\n* Copyright 2014 the original author or authors\n* @license MIT, see LICENSE.txt for details\n*\n* @author Scott Andrews\n*/\n(function (define) {\n  'use strict';\n\n  var undef;\n  define(function\n    /* require */\n  () {\n    /**\n     * Parse a MIME type into it's constituent parts\n     *\n     * @param {string} mime MIME type to parse\n     * @return {{\n     *   {string} raw the original MIME type\n     *   {string} type the type and subtype\n     *   {string} [suffix] mime suffix, including the plus, if any\n     *   {Object} params key/value pair of attributes\n     * }}\n     */\n    function parse(mime) {\n      var params, type;\n      params = mime.split(';');\n      type = params[0].trim().split('+');\n      return {\n        raw: mime,\n        type: type[0],\n        suffix: type[1] ? '+' + type[1] : '',\n        params: params.slice(1).reduce(function (params, pair) {\n          pair = pair.split('=');\n          params[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;\n          return params;\n        }, {})\n      };\n    }\n\n    return {\n      parse: parse\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n} // Boilerplate for AMD and Node\n);","map":{"version":3,"names":["define","undef","parse","mime","params","type","split","trim","raw","suffix","slice","reduce","pair","amd","factory","module","exports","require"],"sources":["D:/Chronicle/chronicle-ttm/src/main/frontend/node_modules/rest/mime.js"],"sourcesContent":["/*\n* Copyright 2014 the original author or authors\n* @license MIT, see LICENSE.txt for details\n*\n* @author Scott Andrews\n*/\n\n(function (define) {\n\t'use strict';\n\n\tvar undef;\n\n\tdefine(function (/* require */) {\n\n\t\t/**\n\t\t * Parse a MIME type into it's constituent parts\n\t\t *\n\t\t * @param {string} mime MIME type to parse\n\t\t * @return {{\n\t\t *   {string} raw the original MIME type\n\t\t *   {string} type the type and subtype\n\t\t *   {string} [suffix] mime suffix, including the plus, if any\n\t\t *   {Object} params key/value pair of attributes\n\t\t * }}\n\t\t */\n\t\tfunction parse(mime) {\n\t\t\tvar params, type;\n\n\t\t\tparams = mime.split(';');\n\t\t\ttype = params[0].trim().split('+');\n\n\t\t\treturn {\n\t\t\t\traw: mime,\n\t\t\t\ttype: type[0],\n\t\t\t\tsuffix: type[1] ? '+' + type[1] : '',\n\t\t\t\tparams: params.slice(1).reduce(function (params, pair) {\n\t\t\t\t\tpair = pair.split('=');\n\t\t\t\t\tparams[pair[0].trim()] = pair[1] ? pair[1].trim() : undef;\n\t\t\t\t\treturn params;\n\t\t\t\t}, {})\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tparse: parse\n\t\t};\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEC,WAAUA,MAAV,EAAkB;EAClB;;EAEA,IAAIC,KAAJ;EAEAD,MAAM,CAAC;IAAU;EAAV,GAAyB;IAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,SAASE,KAAT,CAAeC,IAAf,EAAqB;MACpB,IAAIC,MAAJ,EAAYC,IAAZ;MAEAD,MAAM,GAAGD,IAAI,CAACG,KAAL,CAAW,GAAX,CAAT;MACAD,IAAI,GAAGD,MAAM,CAAC,CAAD,CAAN,CAAUG,IAAV,GAAiBD,KAAjB,CAAuB,GAAvB,CAAP;MAEA,OAAO;QACNE,GAAG,EAAEL,IADC;QAENE,IAAI,EAAEA,IAAI,CAAC,CAAD,CAFJ;QAGNI,MAAM,EAAEJ,IAAI,CAAC,CAAD,CAAJ,GAAU,MAAMA,IAAI,CAAC,CAAD,CAApB,GAA0B,EAH5B;QAIND,MAAM,EAAEA,MAAM,CAACM,KAAP,CAAa,CAAb,EAAgBC,MAAhB,CAAuB,UAAUP,MAAV,EAAkBQ,IAAlB,EAAwB;UACtDA,IAAI,GAAGA,IAAI,CAACN,KAAL,CAAW,GAAX,CAAP;UACAF,MAAM,CAACQ,IAAI,CAAC,CAAD,CAAJ,CAAQL,IAAR,EAAD,CAAN,GAAyBK,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAJ,CAAQL,IAAR,EAAV,GAA2BN,KAApD;UACA,OAAOG,MAAP;QACA,CAJO,EAIL,EAJK;MAJF,CAAP;IAUA;;IAED,OAAO;MACNF,KAAK,EAAEA;IADD,CAAP;EAIA,CAnCK,CAAN;AAqCA,CA1CA,EA2CA,OAAOF,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACa,GAAvC,GAA6Cb,MAA7C,GAAsD,UAAUc,OAAV,EAAmB;EAAEC,MAAM,CAACC,OAAP,GAAiBF,OAAO,CAACG,OAAD,CAAxB;AAAoC,CA3C/G,CA4CA;AA5CA,CAAD"},"metadata":{},"sourceType":"script"}