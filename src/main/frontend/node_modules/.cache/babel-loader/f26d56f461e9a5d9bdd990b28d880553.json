{"ast":null,"code":"/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var defaultClient, mixin, responsePromise, client, when;\n    defaultClient = require('./client/default');\n    mixin = require('./util/mixin');\n    responsePromise = require('./util/responsePromise');\n    client = require('./client');\n    when = require('when');\n    /**\n     * Interceptors have the ability to intercept the request and/org response\n     * objects.  They may augment, prune, transform or replace the\n     * request/response as needed.  Clients may be composed by wrapping\n     * together multiple interceptors.\n     *\n     * Configured interceptors are functional in nature.  Wrapping a client in\n     * an interceptor will not affect the client, merely the data that flows in\n     * and out of that client.  A common configuration can be created once and\n     * shared; specialization can be created by further wrapping that client\n     * with custom interceptors.\n     *\n     * @param {Client} [target] client to wrap\n     * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n     * @returns {Client} A client wrapped with the interceptor\n     *\n     * @class Interceptor\n     */\n\n    function defaultInitHandler(config) {\n      return config;\n    }\n\n    function defaultRequestHandler(request\n    /*, config, meta */\n    ) {\n      return request;\n    }\n\n    function defaultResponseHandler(response\n    /*, config, meta */\n    ) {\n      return response;\n    }\n\n    function race(promisesOrValues) {\n      // this function is different than when.any as the first to reject also wins\n      return when.promise(function (resolve, reject) {\n        promisesOrValues.forEach(function (promiseOrValue) {\n          when(promiseOrValue, resolve, reject);\n        });\n      });\n    }\n    /**\n     * Alternate return type for the request handler that allows for more complex interactions.\n     *\n     * @param properties.request the traditional request return object\n     * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n     * @param {Client} [properties.client] override the defined client with an alternate client\n     * @param [properties.response] response for the request, short circuit the request\n     */\n\n\n    function ComplexRequest(properties) {\n      if (!(this instanceof ComplexRequest)) {\n        // in case users forget the 'new' don't mix into the interceptor\n        return new ComplexRequest(properties);\n      }\n\n      mixin(this, properties);\n    }\n    /**\n     * Create a new interceptor for the provided handlers.\n     *\n     * @param {Function} [handlers.init] one time intialization, must return the config object\n     * @param {Function} [handlers.request] request handler\n     * @param {Function} [handlers.response] response handler regardless of error state\n     * @param {Function} [handlers.success] response handler when the request is not in error\n     * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n     * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n     *\n     * @returns {Interceptor}\n     */\n\n\n    function interceptor(handlers) {\n      var initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n      handlers = handlers || {};\n      initHandler = handlers.init || defaultInitHandler;\n      requestHandler = handlers.request || defaultRequestHandler;\n      successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\n      errorResponseHandler = handlers.error || function () {\n        // Propagate the rejection, with the result of the handler\n        return when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);\n      };\n\n      return function (target, config) {\n        if (typeof target === 'object') {\n          config = target;\n        }\n\n        if (typeof target !== 'function') {\n          target = handlers.client || defaultClient;\n        }\n\n        config = initHandler(config || {});\n\n        function interceptedClient(request) {\n          var context, meta;\n          context = {};\n          meta = {\n            'arguments': Array.prototype.slice.call(arguments),\n            client: interceptedClient\n          };\n          request = typeof request === 'string' ? {\n            path: request\n          } : request || {};\n          request.originator = request.originator || interceptedClient;\n          return responsePromise(requestHandler.call(context, request, config, meta), function (request) {\n            var response, abort, next;\n            next = target;\n\n            if (request instanceof ComplexRequest) {\n              // unpack request\n              abort = request.abort;\n              next = request.client || next;\n              response = request.response; // normalize request, must be last\n\n              request = request.request;\n            }\n\n            response = response || when(request, function (request) {\n              return when(next(request), function (response) {\n                return successResponseHandler.call(context, response, config, meta);\n              }, function (response) {\n                return errorResponseHandler.call(context, response, config, meta);\n              });\n            });\n            return abort ? race([response, abort]) : response;\n          }, function (error) {\n            return when.reject({\n              request: request,\n              error: error\n            });\n          });\n        }\n\n        return client(interceptedClient, target);\n      };\n    }\n\n    interceptor.ComplexRequest = ComplexRequest;\n    return interceptor;\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n} // Boilerplate for AMD and Node\n);","map":{"version":3,"names":["define","require","defaultClient","mixin","responsePromise","client","when","defaultInitHandler","config","defaultRequestHandler","request","defaultResponseHandler","response","race","promisesOrValues","promise","resolve","reject","forEach","promiseOrValue","ComplexRequest","properties","interceptor","handlers","initHandler","requestHandler","successResponseHandler","errorResponseHandler","init","success","error","apply","arguments","target","interceptedClient","context","meta","Array","prototype","slice","call","path","originator","abort","next","amd","factory","module","exports"],"sources":["D:/Chronicle/chronicle-ttm/src/main/frontend/node_modules/rest/interceptor.js"],"sourcesContent":["/*\n * Copyright 2012-2015 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n\n(function (define) {\n\t'use strict';\n\n\tdefine(function (require) {\n\n\t\tvar defaultClient, mixin, responsePromise, client, when;\n\n\t\tdefaultClient = require('./client/default');\n\t\tmixin = require('./util/mixin');\n\t\tresponsePromise = require('./util/responsePromise');\n\t\tclient = require('./client');\n\t\twhen = require('when');\n\n\t\t/**\n\t\t * Interceptors have the ability to intercept the request and/org response\n\t\t * objects.  They may augment, prune, transform or replace the\n\t\t * request/response as needed.  Clients may be composed by wrapping\n\t\t * together multiple interceptors.\n\t\t *\n\t\t * Configured interceptors are functional in nature.  Wrapping a client in\n\t\t * an interceptor will not affect the client, merely the data that flows in\n\t\t * and out of that client.  A common configuration can be created once and\n\t\t * shared; specialization can be created by further wrapping that client\n\t\t * with custom interceptors.\n\t\t *\n\t\t * @param {Client} [target] client to wrap\n\t\t * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation\n\t\t * @returns {Client} A client wrapped with the interceptor\n\t\t *\n\t\t * @class Interceptor\n\t\t */\n\n\t\tfunction defaultInitHandler(config) {\n\t\t\treturn config;\n\t\t}\n\n\t\tfunction defaultRequestHandler(request /*, config, meta */) {\n\t\t\treturn request;\n\t\t}\n\n\t\tfunction defaultResponseHandler(response /*, config, meta */) {\n\t\t\treturn response;\n\t\t}\n\n\t\tfunction race(promisesOrValues) {\n\t\t\t// this function is different than when.any as the first to reject also wins\n\t\t\treturn when.promise(function (resolve, reject) {\n\t\t\t\tpromisesOrValues.forEach(function (promiseOrValue) {\n\t\t\t\t\twhen(promiseOrValue, resolve, reject);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Alternate return type for the request handler that allows for more complex interactions.\n\t\t *\n\t\t * @param properties.request the traditional request return object\n\t\t * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted\n\t\t * @param {Client} [properties.client] override the defined client with an alternate client\n\t\t * @param [properties.response] response for the request, short circuit the request\n\t\t */\n\t\tfunction ComplexRequest(properties) {\n\t\t\tif (!(this instanceof ComplexRequest)) {\n\t\t\t\t// in case users forget the 'new' don't mix into the interceptor\n\t\t\t\treturn new ComplexRequest(properties);\n\t\t\t}\n\t\t\tmixin(this, properties);\n\t\t}\n\n\t\t/**\n\t\t * Create a new interceptor for the provided handlers.\n\t\t *\n\t\t * @param {Function} [handlers.init] one time intialization, must return the config object\n\t\t * @param {Function} [handlers.request] request handler\n\t\t * @param {Function} [handlers.response] response handler regardless of error state\n\t\t * @param {Function} [handlers.success] response handler when the request is not in error\n\t\t * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state\n\t\t * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client\n\t\t *\n\t\t * @returns {Interceptor}\n\t\t */\n\t\tfunction interceptor(handlers) {\n\n\t\t\tvar initHandler, requestHandler, successResponseHandler, errorResponseHandler;\n\n\t\t\thandlers = handlers || {};\n\n\t\t\tinitHandler            = handlers.init    || defaultInitHandler;\n\t\t\trequestHandler         = handlers.request || defaultRequestHandler;\n\t\t\tsuccessResponseHandler = handlers.success || handlers.response || defaultResponseHandler;\n\t\t\terrorResponseHandler   = handlers.error   || function () {\n\t\t\t\t// Propagate the rejection, with the result of the handler\n\t\t\t\treturn when((handlers.response || defaultResponseHandler).apply(this, arguments), when.reject, when.reject);\n\t\t\t};\n\n\t\t\treturn function (target, config) {\n\n\t\t\t\tif (typeof target === 'object') {\n\t\t\t\t\tconfig = target;\n\t\t\t\t}\n\t\t\t\tif (typeof target !== 'function') {\n\t\t\t\t\ttarget = handlers.client || defaultClient;\n\t\t\t\t}\n\n\t\t\t\tconfig = initHandler(config || {});\n\n\t\t\t\tfunction interceptedClient(request) {\n\t\t\t\t\tvar context, meta;\n\t\t\t\t\tcontext = {};\n\t\t\t\t\tmeta = { 'arguments': Array.prototype.slice.call(arguments), client: interceptedClient };\n\t\t\t\t\trequest = typeof request === 'string' ? { path: request } : request || {};\n\t\t\t\t\trequest.originator = request.originator || interceptedClient;\n\t\t\t\t\treturn responsePromise(\n\t\t\t\t\t\trequestHandler.call(context, request, config, meta),\n\t\t\t\t\t\tfunction (request) {\n\t\t\t\t\t\t\tvar response, abort, next;\n\t\t\t\t\t\t\tnext = target;\n\t\t\t\t\t\t\tif (request instanceof ComplexRequest) {\n\t\t\t\t\t\t\t\t// unpack request\n\t\t\t\t\t\t\t\tabort = request.abort;\n\t\t\t\t\t\t\t\tnext = request.client || next;\n\t\t\t\t\t\t\t\tresponse = request.response;\n\t\t\t\t\t\t\t\t// normalize request, must be last\n\t\t\t\t\t\t\t\trequest = request.request;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresponse = response || when(request, function (request) {\n\t\t\t\t\t\t\t\treturn when(\n\t\t\t\t\t\t\t\t\tnext(request),\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn successResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction (response) {\n\t\t\t\t\t\t\t\t\t\treturn errorResponseHandler.call(context, response, config, meta);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn abort ? race([response, abort]) : response;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (error) {\n\t\t\t\t\t\t\treturn when.reject({ request: request, error: error });\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn client(interceptedClient, target);\n\t\t\t};\n\t\t}\n\n\t\tinterceptor.ComplexRequest = ComplexRequest;\n\n\t\treturn interceptor;\n\n\t});\n\n}(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}