{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var state = require('../state');\n\n    var applier = require('../apply');\n\n    return function array(Promise) {\n      var applyFold = applier(Promise);\n      var toPromise = Promise.resolve;\n      var all = Promise.all;\n      var ar = Array.prototype.reduce;\n      var arr = Array.prototype.reduceRight;\n      var slice = Array.prototype.slice; // Additional array combinators\n\n      Promise.any = any;\n      Promise.some = some;\n      Promise.settle = settle;\n      Promise.map = map;\n      Promise.filter = filter;\n      Promise.reduce = reduce;\n      Promise.reduceRight = reduceRight;\n      /**\n       * When this promise fulfills with an array, do\n       * onFulfilled.apply(void 0, array)\n       * @param {function} onFulfilled function to apply\n       * @returns {Promise} promise for the result of applying onFulfilled\n       */\n\n      Promise.prototype.spread = function (onFulfilled) {\n        return this.then(all).then(function (array) {\n          return onFulfilled.apply(this, array);\n        });\n      };\n\n      return Promise;\n      /**\n       * One-winner competitive race.\n       * Return a promise that will fulfill when one of the promises\n       * in the input array fulfills, or will reject when all promises\n       * have rejected.\n       * @param {array} promises\n       * @returns {Promise} promise for the first fulfilled value\n       */\n\n      function any(promises) {\n        var p = Promise._defer();\n\n        var resolver = p._handler;\n        var l = promises.length >>> 0;\n        var pending = l;\n        var errors = [];\n\n        for (var h, x, i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n\n          h = Promise._handler(x);\n\n          if (h.state() > 0) {\n            resolver.become(h);\n\n            Promise._visitRemaining(promises, i, h);\n\n            break;\n          } else {\n            h.visit(resolver, handleFulfill, handleReject);\n          }\n        }\n\n        if (pending === 0) {\n          resolver.reject(new RangeError('any(): array must not be empty'));\n        }\n\n        return p;\n\n        function handleFulfill(x) {\n          /*jshint validthis:true*/\n          errors = null;\n          this.resolve(x); // this === resolver\n        }\n\n        function handleReject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          errors.push(e);\n\n          if (--pending === 0) {\n            this.reject(errors);\n          }\n        }\n      }\n      /**\n       * N-winner competitive race\n       * Return a promise that will fulfill when n input promises have\n       * fulfilled, or will reject when it becomes impossible for n\n       * input promises to fulfill (ie when promises.length - n + 1\n       * have rejected)\n       * @param {array} promises\n       * @param {number} n\n       * @returns {Promise} promise for the earliest n fulfillment values\n       *\n       * @deprecated\n       */\n\n\n      function some(promises, n) {\n        /*jshint maxcomplexity:7*/\n        var p = Promise._defer();\n\n        var resolver = p._handler;\n        var results = [];\n        var errors = [];\n        var l = promises.length >>> 0;\n        var nFulfill = 0;\n        var nReject;\n        var x, i; // reused in both for() loops\n        // First pass: count actual array items\n\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          ++nFulfill;\n        } // Compute actual goals\n\n\n        n = Math.max(n, 0);\n        nReject = nFulfill - n + 1;\n        nFulfill = Math.min(n, nFulfill);\n\n        if (n > nFulfill) {\n          resolver.reject(new RangeError('some(): array must contain at least ' + n + ' item(s), but had ' + nFulfill));\n        } else if (nFulfill === 0) {\n          resolver.resolve(results);\n        } // Second pass: observe each array item, make progress toward goals\n\n\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n        }\n\n        return p;\n\n        function fulfill(x) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          results.push(x);\n\n          if (--nFulfill === 0) {\n            errors = null;\n            this.resolve(results);\n          }\n        }\n\n        function reject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          errors.push(e);\n\n          if (--nReject === 0) {\n            results = null;\n            this.reject(errors);\n          }\n        }\n      }\n      /**\n       * Apply f to the value of each promise in a list of promises\n       * and return a new list containing the results.\n       * @param {array} promises\n       * @param {function(x:*, index:Number):*} f mapping function\n       * @returns {Promise}\n       */\n\n\n      function map(promises, f) {\n        return Promise._traverse(f, promises);\n      }\n      /**\n       * Filter the provided array of promises using the provided predicate.  Input may\n       * contain promises and values\n       * @param {Array} promises array of promises and values\n       * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n       *  Must return truthy (or promise for truthy) for items to retain.\n       * @returns {Promise} promise that will fulfill with an array containing all items\n       *  for which predicate returned truthy.\n       */\n\n\n      function filter(promises, predicate) {\n        var a = slice.call(promises);\n        return Promise._traverse(predicate, a).then(function (keep) {\n          return filterSync(a, keep);\n        });\n      }\n\n      function filterSync(promises, keep) {\n        // Safe because we know all promises have fulfilled if we've made it this far\n        var l = keep.length;\n        var filtered = new Array(l);\n\n        for (var i = 0, j = 0; i < l; ++i) {\n          if (keep[i]) {\n            filtered[j++] = Promise._handler(promises[i]).value;\n          }\n        }\n\n        filtered.length = j;\n        return filtered;\n      }\n      /**\n       * Return a promise that will always fulfill with an array containing\n       * the outcome states of all input promises.  The returned promise\n       * will never reject.\n       * @param {Array} promises\n       * @returns {Promise} promise for array of settled state descriptors\n       */\n\n\n      function settle(promises) {\n        return all(promises.map(settleOne));\n      }\n\n      function settleOne(p) {\n        // Optimize the case where we get an already-resolved when.js promise\n        //  by extracting its state:\n        var handler;\n\n        if (p instanceof Promise) {\n          // This is our own Promise type and we can reach its handler internals:\n          handler = p._handler.join();\n        }\n\n        if (handler && handler.state() === 0 || !handler) {\n          // Either still pending, or not a Promise at all:\n          return toPromise(p).then(state.fulfilled, state.rejected);\n        } // The promise is our own, but it is already resolved. Take a shortcut.\n        // Since we're not actually handling the resolution, we need to disable\n        // rejection reporting.\n\n\n        handler._unreport();\n\n        return state.inspect(handler);\n      }\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n\n\n      function reduce(promises, f\n      /*, initialValue */\n      ) {\n        return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2]) : ar.call(promises, liftCombine(f));\n      }\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n\n\n      function reduceRight(promises, f\n      /*, initialValue */\n      ) {\n        return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2]) : arr.call(promises, liftCombine(f));\n      }\n\n      function liftCombine(f) {\n        return function (z, x, i) {\n          return applyFold(f, void 0, [z, x, i]);\n        };\n      }\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"names":["define","require","state","applier","array","Promise","applyFold","toPromise","resolve","all","ar","Array","prototype","reduce","arr","reduceRight","slice","any","some","settle","map","filter","spread","onFulfilled","then","apply","promises","p","_defer","resolver","_handler","l","length","pending","errors","h","x","i","become","_visitRemaining","visit","handleFulfill","handleReject","reject","RangeError","e","resolved","push","n","results","nFulfill","nReject","Math","max","min","fulfill","notify","f","_traverse","predicate","a","call","keep","filterSync","filtered","j","value","settleOne","handler","join","fulfilled","rejected","_unreport","inspect","arguments","liftCombine","z","amd","factory","module","exports"],"sources":["D:/Chronicle/chronicle-ttm/src/main/frontend/node_modules/when/lib/decorators/array.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\t// Optimize the case where we get an already-resolved when.js promise\n\t\t\t//  by extracting its state:\n\t\t\tvar handler;\n\t\t\tif (p instanceof Promise) {\n\t\t\t\t// This is our own Promise type and we can reach its handler internals:\n\t\t\t\thandler = p._handler.join();\n\t\t\t}\n\t\t\tif((handler && handler.state() === 0) || !handler) {\n\t\t\t\t// Either still pending, or not a Promise at all:\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\t// The promise is our own, but it is already resolved. Take a shortcut.\n\t\t\t// Since we're not actually handling the resolution, we need to disable\n\t\t\t// rejection reporting.\n\t\t\thandler._unreport();\n\t\t\treturn state.inspect(handler);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}