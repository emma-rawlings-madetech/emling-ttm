{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function makePromise(environment) {\n      var tasks = environment.scheduler;\n      var emitRejection = initEmitRejection();\n\n      var objectCreate = Object.create || function (proto) {\n        function Child() {}\n\n        Child.prototype = proto;\n        return new Child();\n      };\n      /**\n       * Create a promise whose fate is determined by resolver\n       * @constructor\n       * @returns {Promise} promise\n       * @name Promise\n       */\n\n\n      function Promise(resolver, handler) {\n        this._handler = resolver === Handler ? handler : init(resolver);\n      }\n      /**\n       * Run the supplied resolver\n       * @param resolver\n       * @returns {Pending}\n       */\n\n\n      function init(resolver) {\n        var handler = new Pending();\n\n        try {\n          resolver(promiseResolve, promiseReject, promiseNotify);\n        } catch (e) {\n          promiseReject(e);\n        }\n\n        return handler;\n        /**\n         * Transition from pre-resolution state to post-resolution state, notifying\n         * all listeners of the ultimate fulfillment or rejection\n         * @param {*} x resolution value\n         */\n\n        function promiseResolve(x) {\n          handler.resolve(x);\n        }\n        /**\n         * Reject this promise with reason, which will be used verbatim\n         * @param {Error|*} reason rejection reason, strongly suggested\n         *   to be an Error type\n         */\n\n\n        function promiseReject(reason) {\n          handler.reject(reason);\n        }\n        /**\n         * @deprecated\n         * Issue a progress event, notifying all progress listeners\n         * @param {*} x progress event payload to pass to all listeners\n         */\n\n\n        function promiseNotify(x) {\n          handler.notify(x);\n        }\n      } // Creation\n\n\n      Promise.resolve = resolve;\n      Promise.reject = reject;\n      Promise.never = never;\n      Promise._defer = defer;\n      Promise._handler = getHandler;\n      /**\n       * Returns a trusted promise. If x is already a trusted promise, it is\n       * returned, otherwise returns a new trusted Promise which follows x.\n       * @param  {*} x\n       * @return {Promise} promise\n       */\n\n      function resolve(x) {\n        return isPromise(x) ? x : new Promise(Handler, new Async(getHandler(x)));\n      }\n      /**\n       * Return a reject promise with x as its reason (x is used verbatim)\n       * @param {*} x\n       * @returns {Promise} rejected promise\n       */\n\n\n      function reject(x) {\n        return new Promise(Handler, new Async(new Rejected(x)));\n      }\n      /**\n       * Return a promise that remains pending forever\n       * @returns {Promise} forever-pending promise.\n       */\n\n\n      function never() {\n        return foreverPendingPromise; // Should be frozen\n      }\n      /**\n       * Creates an internal {promise, resolver} pair\n       * @private\n       * @returns {Promise}\n       */\n\n\n      function defer() {\n        return new Promise(Handler, new Pending());\n      } // Transformation and flow control\n\n      /**\n       * Transform this promise's fulfillment value, returning a new Promise\n       * for the transformed result.  If the promise cannot be fulfilled, onRejected\n       * is called with the reason.  onProgress *may* be called with updates toward\n       * this promise's fulfillment.\n       * @param {function=} onFulfilled fulfillment handler\n       * @param {function=} onRejected rejection handler\n       * @param {function=} onProgress @deprecated progress handler\n       * @return {Promise} new promise\n       */\n\n\n      Promise.prototype.then = function (onFulfilled, onRejected, onProgress) {\n        var parent = this._handler;\n        var state = parent.join().state();\n\n        if (typeof onFulfilled !== 'function' && state > 0 || typeof onRejected !== 'function' && state < 0) {\n          // Short circuit: value will not change, simply share handler\n          return new this.constructor(Handler, parent);\n        }\n\n        var p = this._beget();\n\n        var child = p._handler;\n        parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n        return p;\n      };\n      /**\n       * If this promise cannot be fulfilled due to an error, call onRejected to\n       * handle the error. Shortcut for .then(undefined, onRejected)\n       * @param {function?} onRejected\n       * @return {Promise}\n       */\n\n\n      Promise.prototype['catch'] = function (onRejected) {\n        return this.then(void 0, onRejected);\n      };\n      /**\n       * Creates a new, pending promise of the same type as this promise\n       * @private\n       * @returns {Promise}\n       */\n\n\n      Promise.prototype._beget = function () {\n        return begetFrom(this._handler, this.constructor);\n      };\n\n      function begetFrom(parent, Promise) {\n        var child = new Pending(parent.receiver, parent.join().context);\n        return new Promise(Handler, child);\n      } // Array combinators\n\n\n      Promise.all = all;\n      Promise.race = race;\n      Promise._traverse = traverse;\n      /**\n       * Return a promise that will fulfill when all promises in the\n       * input array have fulfilled, or will reject when one of the\n       * promises rejects.\n       * @param {array} promises array of promises\n       * @returns {Promise} promise for array of fulfillment values\n       */\n\n      function all(promises) {\n        return traverseWith(snd, null, promises);\n      }\n      /**\n       * Array<Promise<X>> -> Promise<Array<f(X)>>\n       * @private\n       * @param {function} f function to apply to each promise's value\n       * @param {Array} promises array of promises\n       * @returns {Promise} promise for transformed values\n       */\n\n\n      function traverse(f, promises) {\n        return traverseWith(tryCatch2, f, promises);\n      }\n\n      function traverseWith(tryMap, f, promises) {\n        var handler = typeof f === 'function' ? mapAt : settleAt;\n        var resolver = new Pending();\n        var pending = promises.length >>> 0;\n        var results = new Array(pending);\n\n        for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n\n          traverseAt(promises, handler, i, x, resolver);\n        }\n\n        if (pending === 0) {\n          resolver.become(new Fulfilled(results));\n        }\n\n        return new Promise(Handler, resolver);\n\n        function mapAt(i, x, resolver) {\n          if (!resolver.resolved) {\n            traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n          }\n        }\n\n        function settleAt(i, x, resolver) {\n          results[i] = x;\n\n          if (--pending === 0) {\n            resolver.become(new Fulfilled(results));\n          }\n        }\n      }\n\n      function traverseAt(promises, handler, i, x, resolver) {\n        if (maybeThenable(x)) {\n          var h = getHandlerMaybeThenable(x);\n          var s = h.state();\n\n          if (s === 0) {\n            h.fold(handler, i, void 0, resolver);\n          } else if (s > 0) {\n            handler(i, h.value, resolver);\n          } else {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n          }\n        } else {\n          handler(i, x, resolver);\n        }\n      }\n\n      Promise._visitRemaining = visitRemaining;\n\n      function visitRemaining(promises, start, handler) {\n        for (var i = start; i < promises.length; ++i) {\n          markAsHandled(getHandler(promises[i]), handler);\n        }\n      }\n\n      function markAsHandled(h, handler) {\n        if (h === handler) {\n          return;\n        }\n\n        var s = h.state();\n\n        if (s === 0) {\n          h.visit(h, void 0, h._unreport);\n        } else if (s < 0) {\n          h._unreport();\n        }\n      }\n      /**\n       * Fulfill-reject competitive race. Return a promise that will settle\n       * to the same state as the earliest input promise to settle.\n       *\n       * WARNING: The ES6 Promise spec requires that race()ing an empty array\n       * must return a promise that is pending forever.  This implementation\n       * returns a singleton forever-pending promise, the same singleton that is\n       * returned by Promise.never(), thus can be checked with ===\n       *\n       * @param {array} promises array of promises to race\n       * @returns {Promise} if input is non-empty, a promise that will settle\n       * to the same outcome as the earliest input promise to settle. if empty\n       * is empty, returns a promise that will never settle.\n       */\n\n\n      function race(promises) {\n        if (typeof promises !== 'object' || promises === null) {\n          return reject(new TypeError('non-iterable passed to race()'));\n        } // Sigh, race([]) is untestable unless we return *something*\n        // that is recognizable without calling .then() on it.\n\n\n        return promises.length === 0 ? never() : promises.length === 1 ? resolve(promises[0]) : runRace(promises);\n      }\n\n      function runRace(promises) {\n        var resolver = new Pending();\n        var i, x, h;\n\n        for (i = 0; i < promises.length; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          h = getHandler(x);\n\n          if (h.state() !== 0) {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n            break;\n          } else {\n            h.visit(resolver, resolver.resolve, resolver.reject);\n          }\n        }\n\n        return new Promise(Handler, resolver);\n      } // Promise internals\n      // Below this, everything is @private\n\n      /**\n       * Get an appropriate handler for x, without checking for cycles\n       * @param {*} x\n       * @returns {object} handler\n       */\n\n\n      function getHandler(x) {\n        if (isPromise(x)) {\n          return x._handler.join();\n        }\n\n        return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n      }\n      /**\n       * Get a handler for thenable x.\n       * NOTE: You must only call this if maybeThenable(x) == true\n       * @param {object|function|Promise} x\n       * @returns {object} handler\n       */\n\n\n      function getHandlerMaybeThenable(x) {\n        return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n      }\n      /**\n       * Get a handler for potentially untrusted thenable x\n       * @param {*} x\n       * @returns {object} handler\n       */\n\n\n      function getHandlerUntrusted(x) {\n        try {\n          var untrustedThen = x.then;\n          return typeof untrustedThen === 'function' ? new Thenable(untrustedThen, x) : new Fulfilled(x);\n        } catch (e) {\n          return new Rejected(e);\n        }\n      }\n      /**\n       * Handler for a promise that is pending forever\n       * @constructor\n       */\n\n\n      function Handler() {}\n\n      Handler.prototype.when = Handler.prototype.become = Handler.prototype.notify // deprecated\n      = Handler.prototype.fail = Handler.prototype._unreport = Handler.prototype._report = noop;\n      Handler.prototype._state = 0;\n\n      Handler.prototype.state = function () {\n        return this._state;\n      };\n      /**\n       * Recursively collapse handler chain to find the handler\n       * nearest to the fully resolved value.\n       * @returns {object} handler nearest the fully resolved value\n       */\n\n\n      Handler.prototype.join = function () {\n        var h = this;\n\n        while (h.handler !== void 0) {\n          h = h.handler;\n        }\n\n        return h;\n      };\n\n      Handler.prototype.chain = function (to, receiver, fulfilled, rejected, progress) {\n        this.when({\n          resolver: to,\n          receiver: receiver,\n          fulfilled: fulfilled,\n          rejected: rejected,\n          progress: progress\n        });\n      };\n\n      Handler.prototype.visit = function (receiver, fulfilled, rejected, progress) {\n        this.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n      };\n\n      Handler.prototype.fold = function (f, z, c, to) {\n        this.when(new Fold(f, z, c, to));\n      };\n      /**\n       * Handler that invokes fail() on any handler it becomes\n       * @constructor\n       */\n\n\n      function FailIfRejected() {}\n\n      inherit(Handler, FailIfRejected);\n\n      FailIfRejected.prototype.become = function (h) {\n        h.fail();\n      };\n\n      var failIfRejected = new FailIfRejected();\n      /**\n       * Handler that manages a queue of consumers waiting on a pending promise\n       * @constructor\n       */\n\n      function Pending(receiver, inheritedContext) {\n        Promise.createContext(this, inheritedContext);\n        this.consumers = void 0;\n        this.receiver = receiver;\n        this.handler = void 0;\n        this.resolved = false;\n      }\n\n      inherit(Handler, Pending);\n      Pending.prototype._state = 0;\n\n      Pending.prototype.resolve = function (x) {\n        this.become(getHandler(x));\n      };\n\n      Pending.prototype.reject = function (x) {\n        if (this.resolved) {\n          return;\n        }\n\n        this.become(new Rejected(x));\n      };\n\n      Pending.prototype.join = function () {\n        if (!this.resolved) {\n          return this;\n        }\n\n        var h = this;\n\n        while (h.handler !== void 0) {\n          h = h.handler;\n\n          if (h === this) {\n            return this.handler = cycle();\n          }\n        }\n\n        return h;\n      };\n\n      Pending.prototype.run = function () {\n        var q = this.consumers;\n        var handler = this.handler;\n        this.handler = this.handler.join();\n        this.consumers = void 0;\n\n        for (var i = 0; i < q.length; ++i) {\n          handler.when(q[i]);\n        }\n      };\n\n      Pending.prototype.become = function (handler) {\n        if (this.resolved) {\n          return;\n        }\n\n        this.resolved = true;\n        this.handler = handler;\n\n        if (this.consumers !== void 0) {\n          tasks.enqueue(this);\n        }\n\n        if (this.context !== void 0) {\n          handler._report(this.context);\n        }\n      };\n\n      Pending.prototype.when = function (continuation) {\n        if (this.resolved) {\n          tasks.enqueue(new ContinuationTask(continuation, this.handler));\n        } else {\n          if (this.consumers === void 0) {\n            this.consumers = [continuation];\n          } else {\n            this.consumers.push(continuation);\n          }\n        }\n      };\n      /**\n       * @deprecated\n       */\n\n\n      Pending.prototype.notify = function (x) {\n        if (!this.resolved) {\n          tasks.enqueue(new ProgressTask(x, this));\n        }\n      };\n\n      Pending.prototype.fail = function (context) {\n        var c = typeof context === 'undefined' ? this.context : context;\n        this.resolved && this.handler.join().fail(c);\n      };\n\n      Pending.prototype._report = function (context) {\n        this.resolved && this.handler.join()._report(context);\n      };\n\n      Pending.prototype._unreport = function () {\n        this.resolved && this.handler.join()._unreport();\n      };\n      /**\n       * Wrap another handler and force it into a future stack\n       * @param {object} handler\n       * @constructor\n       */\n\n\n      function Async(handler) {\n        this.handler = handler;\n      }\n\n      inherit(Handler, Async);\n\n      Async.prototype.when = function (continuation) {\n        tasks.enqueue(new ContinuationTask(continuation, this));\n      };\n\n      Async.prototype._report = function (context) {\n        this.join()._report(context);\n      };\n\n      Async.prototype._unreport = function () {\n        this.join()._unreport();\n      };\n      /**\n       * Handler that wraps an untrusted thenable and assimilates it in a future stack\n       * @param {function} then\n       * @param {{then: function}} thenable\n       * @constructor\n       */\n\n\n      function Thenable(then, thenable) {\n        Pending.call(this);\n        tasks.enqueue(new AssimilateTask(then, thenable, this));\n      }\n\n      inherit(Pending, Thenable);\n      /**\n       * Handler for a fulfilled promise\n       * @param {*} x fulfillment value\n       * @constructor\n       */\n\n      function Fulfilled(x) {\n        Promise.createContext(this);\n        this.value = x;\n      }\n\n      inherit(Handler, Fulfilled);\n      Fulfilled.prototype._state = 1;\n\n      Fulfilled.prototype.fold = function (f, z, c, to) {\n        runContinuation3(f, z, this, c, to);\n      };\n\n      Fulfilled.prototype.when = function (cont) {\n        runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n      };\n\n      var errorId = 0;\n      /**\n       * Handler for a rejected promise\n       * @param {*} x rejection reason\n       * @constructor\n       */\n\n      function Rejected(x) {\n        Promise.createContext(this);\n        this.id = ++errorId;\n        this.value = x;\n        this.handled = false;\n        this.reported = false;\n\n        this._report();\n      }\n\n      inherit(Handler, Rejected);\n      Rejected.prototype._state = -1;\n\n      Rejected.prototype.fold = function (f, z, c, to) {\n        to.become(this);\n      };\n\n      Rejected.prototype.when = function (cont) {\n        if (typeof cont.rejected === 'function') {\n          this._unreport();\n        }\n\n        runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n      };\n\n      Rejected.prototype._report = function (context) {\n        tasks.afterQueue(new ReportTask(this, context));\n      };\n\n      Rejected.prototype._unreport = function () {\n        if (this.handled) {\n          return;\n        }\n\n        this.handled = true;\n        tasks.afterQueue(new UnreportTask(this));\n      };\n\n      Rejected.prototype.fail = function (context) {\n        this.reported = true;\n        emitRejection('unhandledRejection', this);\n        Promise.onFatalRejection(this, context === void 0 ? this.context : context);\n      };\n\n      function ReportTask(rejection, context) {\n        this.rejection = rejection;\n        this.context = context;\n      }\n\n      ReportTask.prototype.run = function () {\n        if (!this.rejection.handled && !this.rejection.reported) {\n          this.rejection.reported = true;\n          emitRejection('unhandledRejection', this.rejection) || Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n        }\n      };\n\n      function UnreportTask(rejection) {\n        this.rejection = rejection;\n      }\n\n      UnreportTask.prototype.run = function () {\n        if (this.rejection.reported) {\n          emitRejection('rejectionHandled', this.rejection) || Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n        }\n      }; // Unhandled rejection hooks\n      // By default, everything is a noop\n\n\n      Promise.createContext = Promise.enterContext = Promise.exitContext = Promise.onPotentiallyUnhandledRejection = Promise.onPotentiallyUnhandledRejectionHandled = Promise.onFatalRejection = noop; // Errors and singletons\n\n      var foreverPendingHandler = new Handler();\n      var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n      function cycle() {\n        return new Rejected(new TypeError('Promise cycle'));\n      } // Task runners\n\n      /**\n       * Run a single consumer\n       * @constructor\n       */\n\n\n      function ContinuationTask(continuation, handler) {\n        this.continuation = continuation;\n        this.handler = handler;\n      }\n\n      ContinuationTask.prototype.run = function () {\n        this.handler.join().when(this.continuation);\n      };\n      /**\n       * Run a queue of progress handlers\n       * @constructor\n       */\n\n\n      function ProgressTask(value, handler) {\n        this.handler = handler;\n        this.value = value;\n      }\n\n      ProgressTask.prototype.run = function () {\n        var q = this.handler.consumers;\n\n        if (q === void 0) {\n          return;\n        }\n\n        for (var c, i = 0; i < q.length; ++i) {\n          c = q[i];\n          runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n        }\n      };\n      /**\n       * Assimilate a thenable, sending it's value to resolver\n       * @param {function} then\n       * @param {object|function} thenable\n       * @param {object} resolver\n       * @constructor\n       */\n\n\n      function AssimilateTask(then, thenable, resolver) {\n        this._then = then;\n        this.thenable = thenable;\n        this.resolver = resolver;\n      }\n\n      AssimilateTask.prototype.run = function () {\n        var h = this.resolver;\n        tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n        function _resolve(x) {\n          h.resolve(x);\n        }\n\n        function _reject(x) {\n          h.reject(x);\n        }\n\n        function _notify(x) {\n          h.notify(x);\n        }\n      };\n\n      function tryAssimilate(then, thenable, resolve, reject, notify) {\n        try {\n          then.call(thenable, resolve, reject, notify);\n        } catch (e) {\n          reject(e);\n        }\n      }\n      /**\n       * Fold a handler value with z\n       * @constructor\n       */\n\n\n      function Fold(f, z, c, to) {\n        this.f = f;\n        this.z = z;\n        this.c = c;\n        this.to = to;\n        this.resolver = failIfRejected;\n        this.receiver = this;\n      }\n\n      Fold.prototype.fulfilled = function (x) {\n        this.f.call(this.c, this.z, x, this.to);\n      };\n\n      Fold.prototype.rejected = function (x) {\n        this.to.reject(x);\n      };\n\n      Fold.prototype.progress = function (x) {\n        this.to.notify(x);\n      }; // Other helpers\n\n      /**\n       * @param {*} x\n       * @returns {boolean} true iff x is a trusted Promise\n       */\n\n\n      function isPromise(x) {\n        return x instanceof Promise;\n      }\n      /**\n       * Test just enough to rule out primitives, in order to take faster\n       * paths in some code\n       * @param {*} x\n       * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n       */\n\n\n      function maybeThenable(x) {\n        return (typeof x === 'object' || typeof x === 'function') && x !== null;\n      }\n\n      function runContinuation1(f, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReject(f, h.value, receiver, next);\n        Promise.exitContext();\n      }\n\n      function runContinuation3(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReject3(f, x, h.value, receiver, next);\n        Promise.exitContext();\n      }\n      /**\n       * @deprecated\n       */\n\n\n      function runNotify(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.notify(x);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReturn(f, x, receiver, next);\n        Promise.exitContext();\n      }\n\n      function tryCatch2(f, a, b) {\n        try {\n          return f(a, b);\n        } catch (e) {\n          return reject(e);\n        }\n      }\n      /**\n       * Return f.call(thisArg, x), or if it throws return a rejected promise for\n       * the thrown exception\n       */\n\n\n      function tryCatchReject(f, x, thisArg, next) {\n        try {\n          next.become(getHandler(f.call(thisArg, x)));\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n      /**\n       * Same as above, but includes the extra argument parameter.\n       */\n\n\n      function tryCatchReject3(f, x, y, thisArg, next) {\n        try {\n          f.call(thisArg, x, y, next);\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n      /**\n       * @deprecated\n       * Return f.call(thisArg, x), or if it throws, *return* the exception\n       */\n\n\n      function tryCatchReturn(f, x, thisArg, next) {\n        try {\n          next.notify(f.call(thisArg, x));\n        } catch (e) {\n          next.notify(e);\n        }\n      }\n\n      function inherit(Parent, Child) {\n        Child.prototype = objectCreate(Parent.prototype);\n        Child.prototype.constructor = Child;\n      }\n\n      function snd(x, y) {\n        return y;\n      }\n\n      function noop() {}\n\n      function hasCustomEvent() {\n        if (typeof CustomEvent === 'function') {\n          try {\n            var ev = new CustomEvent('unhandledRejection');\n            return ev instanceof CustomEvent;\n          } catch (ignoredException) {}\n        }\n\n        return false;\n      }\n\n      function hasInternetExplorerCustomEvent() {\n        if (typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n          try {\n            // Try to create one event to make sure it's supported\n            var ev = document.createEvent('CustomEvent');\n            ev.initCustomEvent('eventType', false, true, {});\n            return true;\n          } catch (ignoredException) {}\n        }\n\n        return false;\n      }\n\n      function initEmitRejection() {\n        /*global process, self, CustomEvent*/\n        if (typeof process !== 'undefined' && process !== null && typeof process.emit === 'function') {\n          // Returning falsy here means to call the default\n          // onPotentiallyUnhandledRejection API.  This is safe even in\n          // browserify since process.emit always returns falsy in browserify:\n          // https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n          return function (type, rejection) {\n            return type === 'unhandledRejection' ? process.emit(type, rejection.value, rejection) : process.emit(type, rejection);\n          };\n        } else if (typeof self !== 'undefined' && hasCustomEvent()) {\n          return function (self, CustomEvent) {\n            return function (type, rejection) {\n              var ev = new CustomEvent(type, {\n                detail: {\n                  reason: rejection.value,\n                  key: rejection\n                },\n                bubbles: false,\n                cancelable: true\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, CustomEvent);\n        } else if (typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n          return function (self, document) {\n            return function (type, rejection) {\n              var ev = document.createEvent('CustomEvent');\n              ev.initCustomEvent(type, false, true, {\n                reason: rejection.value,\n                key: rejection\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, document);\n        }\n\n        return noop;\n      }\n\n      return Promise;\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"names":["define","makePromise","environment","tasks","scheduler","emitRejection","initEmitRejection","objectCreate","Object","create","proto","Child","prototype","Promise","resolver","handler","_handler","Handler","init","Pending","promiseResolve","promiseReject","promiseNotify","e","x","resolve","reason","reject","notify","never","_defer","defer","getHandler","isPromise","Async","Rejected","foreverPendingPromise","then","onFulfilled","onRejected","onProgress","parent","state","join","constructor","p","_beget","child","chain","receiver","begetFrom","context","all","race","_traverse","traverse","promises","traverseWith","snd","f","tryCatch2","tryMap","mapAt","settleAt","pending","length","results","Array","i","resolved","traverseAt","become","Fulfilled","maybeThenable","h","getHandlerMaybeThenable","s","fold","value","visitRemaining","_visitRemaining","start","markAsHandled","visit","_unreport","TypeError","runRace","getHandlerUntrusted","untrustedThen","Thenable","when","fail","_report","noop","_state","to","fulfilled","rejected","progress","failIfRejected","z","c","Fold","FailIfRejected","inherit","inheritedContext","createContext","consumers","cycle","run","q","enqueue","continuation","ContinuationTask","push","ProgressTask","thenable","call","AssimilateTask","runContinuation3","cont","runContinuation1","errorId","id","handled","reported","afterQueue","ReportTask","UnreportTask","onFatalRejection","rejection","onPotentiallyUnhandledRejection","onPotentiallyUnhandledRejectionHandled","enterContext","exitContext","foreverPendingHandler","runNotify","_then","tryAssimilate","_resolve","_reject","_notify","next","tryCatchReject","tryCatchReject3","tryCatchReturn","a","b","thisArg","y","Parent","hasCustomEvent","CustomEvent","ev","ignoredException","hasInternetExplorerCustomEvent","document","createEvent","initCustomEvent","process","emit","type","self","detail","key","bubbles","cancelable","dispatchEvent","amd","factory","module","exports"],"sources":["D:/Chronicle/chronicle-ttm/src/main/frontend/node_modules/when/lib/makePromise.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction hasCustomEvent() {\n\t\t\tif(typeof CustomEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\treturn ev instanceof CustomEvent;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction hasInternetExplorerCustomEvent() {\n\t\t\tif(typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\t// Try to create one event to make sure it's supported\n\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\tev.initCustomEvent('eventType', false, true, {});\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && hasCustomEvent()) {\n\t\t\t\treturn (function (self, CustomEvent) {\n\t\t\t\t\treturn function (type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, CustomEvent));\n\t\t\t} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n\t\t\t\treturn (function(self, document) {\n\t\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\t\tev.initCustomEvent(type, false, true, {\n\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, document));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}