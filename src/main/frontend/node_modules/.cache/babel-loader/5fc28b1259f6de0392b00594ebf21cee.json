{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    // Credit to Twisol (https://github.com/Twisol) for suggesting\n    // this type of extensible queue + trampoline approach for next-tick conflation.\n\n    /**\n     * Async task scheduler\n     * @param {function} async function to schedule a single async function\n     * @constructor\n     */\n    function Scheduler(async) {\n      this._async = async;\n      this._running = false;\n      this._queue = this;\n      this._queueLen = 0;\n      this._afterQueue = {};\n      this._afterQueueLen = 0;\n      var self = this;\n\n      this.drain = function () {\n        self._drain();\n      };\n    }\n    /**\n     * Enqueue a task\n     * @param {{ run:function }} task\n     */\n\n\n    Scheduler.prototype.enqueue = function (task) {\n      this._queue[this._queueLen++] = task;\n      this.run();\n    };\n    /**\n     * Enqueue a task to run after the main task queue\n     * @param {{ run:function }} task\n     */\n\n\n    Scheduler.prototype.afterQueue = function (task) {\n      this._afterQueue[this._afterQueueLen++] = task;\n      this.run();\n    };\n\n    Scheduler.prototype.run = function () {\n      if (!this._running) {\n        this._running = true;\n\n        this._async(this.drain);\n      }\n    };\n    /**\n     * Drain the handler queue entirely, and then the after queue\n     */\n\n\n    Scheduler.prototype._drain = function () {\n      var i = 0;\n\n      for (; i < this._queueLen; ++i) {\n        this._queue[i].run();\n\n        this._queue[i] = void 0;\n      }\n\n      this._queueLen = 0;\n      this._running = false;\n\n      for (i = 0; i < this._afterQueueLen; ++i) {\n        this._afterQueue[i].run();\n\n        this._afterQueue[i] = void 0;\n      }\n\n      this._afterQueueLen = 0;\n    };\n\n    return Scheduler;\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"names":["define","Scheduler","async","_async","_running","_queue","_queueLen","_afterQueue","_afterQueueLen","self","drain","_drain","prototype","enqueue","task","run","afterQueue","i","amd","factory","module","exports"],"sources":["D:/Chronicle/chronicle-ttm/src/main/frontend/node_modules/when/lib/Scheduler.js"],"sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._running = false;\n\n\t\tthis._queue = this;\n\t\tthis._queueLen = 0;\n\t\tthis._afterQueue = {};\n\t\tthis._afterQueueLen = 0;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._queue[this._queueLen++] = task;\n\t\tthis.run();\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._afterQueue[this._afterQueueLen++] = task;\n\t\tthis.run();\n\t};\n\n\tScheduler.prototype.run = function() {\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\tvar i = 0;\n\t\tfor (; i < this._queueLen; ++i) {\n\t\t\tthis._queue[i].run();\n\t\t\tthis._queue[i] = void 0;\n\t\t}\n\n\t\tthis._queueLen = 0;\n\t\tthis._running = false;\n\n\t\tfor (i = 0; i < this._afterQueueLen; ++i) {\n\t\t\tthis._afterQueue[i].run();\n\t\t\tthis._afterQueue[i] = void 0;\n\t\t}\n\n\t\tthis._afterQueueLen = 0;\n\t};\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"],"mappings":"AAAA;;AACA;;AACA;AAEC,WAASA,MAAT,EAAiB;EAAE;;EACpBA,MAAM,CAAC,YAAW;IAEjB;IACA;;IAEA;AACD;AACA;AACA;AACA;IACC,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;MACzB,KAAKC,MAAL,GAAcD,KAAd;MACA,KAAKE,QAAL,GAAgB,KAAhB;MAEA,KAAKC,MAAL,GAAc,IAAd;MACA,KAAKC,SAAL,GAAiB,CAAjB;MACA,KAAKC,WAAL,GAAmB,EAAnB;MACA,KAAKC,cAAL,GAAsB,CAAtB;MAEA,IAAIC,IAAI,GAAG,IAAX;;MACA,KAAKC,KAAL,GAAa,YAAW;QACvBD,IAAI,CAACE,MAAL;MACA,CAFD;IAGA;IAED;AACD;AACA;AACA;;;IACCV,SAAS,CAACW,SAAV,CAAoBC,OAApB,GAA8B,UAASC,IAAT,EAAe;MAC5C,KAAKT,MAAL,CAAY,KAAKC,SAAL,EAAZ,IAAgCQ,IAAhC;MACA,KAAKC,GAAL;IACA,CAHD;IAKA;AACD;AACA;AACA;;;IACCd,SAAS,CAACW,SAAV,CAAoBI,UAApB,GAAiC,UAASF,IAAT,EAAe;MAC/C,KAAKP,WAAL,CAAiB,KAAKC,cAAL,EAAjB,IAA0CM,IAA1C;MACA,KAAKC,GAAL;IACA,CAHD;;IAKAd,SAAS,CAACW,SAAV,CAAoBG,GAApB,GAA0B,YAAW;MACpC,IAAI,CAAC,KAAKX,QAAV,EAAoB;QACnB,KAAKA,QAAL,GAAgB,IAAhB;;QACA,KAAKD,MAAL,CAAY,KAAKO,KAAjB;MACA;IACD,CALD;IAOA;AACD;AACA;;;IACCT,SAAS,CAACW,SAAV,CAAoBD,MAApB,GAA6B,YAAW;MACvC,IAAIM,CAAC,GAAG,CAAR;;MACA,OAAOA,CAAC,GAAG,KAAKX,SAAhB,EAA2B,EAAEW,CAA7B,EAAgC;QAC/B,KAAKZ,MAAL,CAAYY,CAAZ,EAAeF,GAAf;;QACA,KAAKV,MAAL,CAAYY,CAAZ,IAAiB,KAAK,CAAtB;MACA;;MAED,KAAKX,SAAL,GAAiB,CAAjB;MACA,KAAKF,QAAL,GAAgB,KAAhB;;MAEA,KAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKT,cAArB,EAAqC,EAAES,CAAvC,EAA0C;QACzC,KAAKV,WAAL,CAAiBU,CAAjB,EAAoBF,GAApB;;QACA,KAAKR,WAAL,CAAiBU,CAAjB,IAAsB,KAAK,CAA3B;MACA;;MAED,KAAKT,cAAL,GAAsB,CAAtB;IACA,CAhBD;;IAkBA,OAAOP,SAAP;EAEA,CAzEK,CAAN;AA0EC,CA3EA,EA2EC,OAAOD,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACkB,GAAvC,GAA6ClB,MAA7C,GAAsD,UAASmB,OAAT,EAAkB;EAAEC,MAAM,CAACC,OAAP,GAAiBF,OAAO,EAAxB;AAA6B,CA3ExG,CAAD"},"metadata":{},"sourceType":"script"}